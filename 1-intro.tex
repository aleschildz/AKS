Una de las preguntas más fundamentales de la matemática, y que ha sido estudiada desde la Antigüedad, es cómo decidir rápidamente si un entero positivo es primo o compuesto. Dicho problema no solo tiene una enorme importancia teórica, sino que también es crucial en criptografía.

Dado un entero positivo $n$, el algoritmo más sencillo posible para decidir primalidad sería revisar si existe algún divisor de $n$ que sea mayor que $1$ y menor que $n$. Esto requerirá del orden de $n$ divisiones. No es difícil convencerse de que, en realidad, solo es necesario hacer esa revisión hasta $\sqrt{n}$, pues cualquier número compuesto debe tener un divisor en ese rango. Esto reduce el número de divisiones del algoritmo al orden de $\sqrt{n}$. Sin embargo, esto sigue siendo demasiado lento. Por ejemplo, decidir si un número de $100$ dígitos es primo usando ese algoritmo podría requerir hasta $\sqrt{10^{100}} = 10^{50}$ divisiones, lo que excede por mucho la capacidad de un computador moderno. Puesto que los protocolos criptográficos actuales trabajan con números de cientos de dígitos, ese algoritmo no es útil. Cuando decimos que nos gustaría contar con un algoritmo rápido, nos referimos a que el número de divisiones debiese crecer de manera polinomial respecto al número de dígitos de la entrada. En otras palabras, necesitamos un algoritmo cuya complejidad en el peor de los casos sea un polinomio respecto a $\log(n)$. Por supuesto, la complejidad asintótica $\sqrt{n}$ que acabamos de discutir no cumple esa condición.


\textcolor{red}{Ale: aquí podríamos agregar una breve discusión sobre tests deterministas bajo cierta condición no probada, y tests aleatorizados. Y terminar diciendo que AKS es el primer algoritmo determinista que corre en tiempo polinomial sin condiciones.}


Finalmente, en el año 2004, Manindra Agrawal, Neeraj Kayal y Nitin Saxena proponen en \cite{AKS04} un algoritmo de primalidad determinista que corre en tiempo polinomial, basado en resultados de teorí­a de números y de álgebra abstracta. Dicho algoritmo es conocido como el test de primalidad AKS. Si bien es muy sencillo de programar, las razones por las que el algoritmo funciona son profundas, y pueden resultar inaccesibles para quienes no están familiarizados con las técnicas utilizadas en la demostración de correctitud presentada en \cite{AKS04}. Por esto, el objetivo del presente trabajo es dar una explicación ampliada y autocontenida del algoritmo, partiendo desde las ideas básicas que están detrás.
